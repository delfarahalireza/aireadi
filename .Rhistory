if (!is.null(record_date) && !is.null(record_time)) {
if (inherits(record_date, "Date") && inherits(record_time, c("hms", "character"))) {
time_str <- as.character(record_time)
datetime_str <- paste(as.character(record_date), time_str)
recording_datetime <- as.POSIXct(datetime_str, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
} else {
cat("  Warning: Could not combine date and time into a single POSIXct object for:", base_path, "\n")
}
}
cat("Dimensions of p_signal:", paste(dim(record$p_signal), collapse = "x"), "\n")
cat("Available signal names:", paste(record$sig_name, collapse = ", "), "\n")
p_signal_r_matrix <- py_to_r(record$p_signal)
signal <- p_signal_r_matrix[, 1]
if (is.null(signal) || !is.numeric(signal) || length(signal) == 0) {
cat("Error: 'signal' is invalid or empty after selection for:", base_path, "\n")
return(NULL)
}
fs <- record$fs
cat("Signal length:", length(signal), "samples\n")
if (length(signal) <= 2253) {
cat("  Skipping: signal too short (", length(signal), "samples)\n")
return(NULL)
}
ecg <- import("biosppy.signals.ecg")
out_py <- ecg$ecg(signal = signal, sampling_rate = fs, show = FALSE)
out_dict_py <- out_py$as_dict()
out_r_list <- py_to_r(out_dict_py)
rpeaks <- NULL
heart_rate <- NULL
if ("rpeaks" %in% names(out_r_list)) {
rpeaks <- out_r_list$rpeaks
} else {
cat("  Warning: 'rpeaks' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if ("heart_rate" %in% names(out_r_list)) {
heart_rate <- out_r_list$heart_rate
} else {
cat("  Warning: 'heart_rate' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if (is.null(rpeaks) || length(rpeaks) < 2) {
cat("  Skipping: Not enough R-peaks found (", length(rpeaks), ") or rpeaks is NULL for RR-intervals for:", base_path, "\n")
return(NULL)
}
rr_intervals <- diff(rpeaks) / fs
if (is.null(heart_rate) || length(heart_rate) == 0) {
cat("  Skipping: Heart rate data is missing or empty for:", base_path, "\n")
return(NULL)
}
# Return a one-row tibble for the participant with list-columns
participant_df <- tibble(
participant_id = participant_id,
record_date = record_date,
record_time = record_time,
recording_datetime = recording_datetime,
mean_hr = mean(heart_rate, na.rm = TRUE),
sdnn = sd(rr_intervals, na.rm = TRUE),
rr_intervals = list(rr_intervals), # Still a list-column
rpeaks = list(rpeaks),             # Still a list-column
heart_rate = list(heart_rate)      # Still a list-column
)
return(participant_df)
}, error = function(e) {
cat("Error processing file:", base_path, "\n")
cat("Error message:", e$message, "\n")
return(NULL)
})
}
participant_folders <- list.dirs(path = folder_path, recursive = FALSE, full.names = FALSE)
participant_folders <- participant_folders[participant_folders != "."]
all_participants_ecg <- list()
participant_folders <- participant_folders[1:2]
for (folder in participant_folders) {
id <- folder
folder_path_full <- file.path(folder_path, folder)
files <- list.files(folder_path_full, pattern = "\\.hea$", full.names = TRUE)
if (length(files) == 0) next
# Assume matching .dat file is present
base_path <- sub("\\.hea$", "", files[1])  # remove .hea extension
features <- extract_ecg_features(base_path)
if (!is.null(features)) {
features$participant_id <- id
all_participants_ecg[[id]] <- features
}
}
all_participants_ecg[["1001"]]
View(all_participants_ecg)
View(all_participants_ecg[["1001"]])
library(reticulate)
library(tidyverse) # This loads dplyr and tidyr, along with tibble and other useful packages
# --- Your existing setup for participant_folders ---
participant_folders <- list.dirs(path = folder_path, recursive = FALSE, full.names = FALSE)
participant_folders <- participant_folders[participant_folders != "."]
# Limiting to first 2 folders for testing, remove this line for full run
participant_folders <- participant_folders[1:2]
# --- Initialize list to store data frames (each with list-columns) ---
all_participants_ecg_raw <- list()
for (folder in participant_folders) {
# 'id' is already extracted within extract_ecg_features now from base_path
# So, we don't need 'id <- folder' here to add it to the features later.
folder_path_full <- file.path(folder_path, folder)
files <- list.files(folder_path_full, pattern = "\\.hea$", full.names = TRUE)
if (length(files) == 0) {
cat("No .hea files found in folder:", folder, "\n")
next # Skip to the next folder if no .hea files are found
}
# Assume matching .dat file is present and take the first .hea file found
base_path <- sub("\\.hea$", "", files[1]) # remove .hea extension
# Call the extract_ecg_features function
# This function now returns a 1-row tibble with list-columns, or NULL if there's an error
features_tibble <- extract_ecg_features(base_path)
if (!is.null(features_tibble)) {
# Store the 1-row tibble directly into our list
all_participants_ecg_raw[[length(all_participants_ecg_raw) + 1]] <- features_tibble
}
}
# --- Post-processing: Combine and Flatten to Long Format ---
cat("\n--- Combining and Flattening Data ---\n")
if (length(all_participants_ecg_raw) == 0) {
cat("No data was successfully extracted from any participant.\n")
final_flat_ecg_data <- tibble() # Create an empty tibble
} else {
# 1. Combine all individual participant tibbles into one large tibble
# This will result in a tibble where each row is a participant summary,
# and rr_intervals, rpeaks, heart_rate are still list-columns.
combined_ecg_data <- bind_rows(all_participants_ecg_raw)
# 2. Use unnest() to flatten the list-columns
# This will create new rows for each element in the list-columns,
# duplicating the other scalar columns (participant_id, mean_hr, etc.)
# for each unnested value.
final_flat_ecg_data <- combined_ecg_data %>%
unnest(c(rr_intervals, rpeaks, heart_rate))
cat("Successfully created a single, long-format data frame.\n")
cat("Final data frame dimensions:", dim(final_flat_ecg_data)[1], "rows,", dim(final_flat_ecg_data)[2], "columns.\n")
}
library(reticulate)
folder_id <- "dataset/cardiac_ecg/ecg_12lead/philips_tc30"
folder_path <- file.path(getwd(), folder_id)
# Use a conda or virtualenv environment if needed
# use_condaenv("your-env")  # optional
# Import required Python modules
wfdb <- import("wfdb")
biosppy <- import("biosppy.signals.ecg")
np <- import("numpy")
# Function to extract features from one ECG file
library(reticulate)
library(tibble)
extract_ecg_features <- function(base_path) {
tryCatch({
record <- wfdb$rdrecord(base_path)
if (is.null(record) || is.null(record$p_signal) || length(dim(record$p_signal)) < 2) {
cat("Error: Problem reading record or p_signal for:", base_path, "\n")
if (!is.null(record) && !is.null(record$p_signal)) {
cat("  Dimensions of p_signal:", paste(dim(record$p_signal), collapse = "x"), "\n")
}
return(NULL)
}
participant_id <- basename(dirname(base_path))
cat("Processing Participant ID:", participant_id, "\n")
# --- Extract time and date information ---
record_date <- NULL
record_time <- NULL
recording_datetime <- NULL
if (!is.null(record$base_date)) {
record_date <- py_to_r(record$base_date)
}
if (!is.null(record$base_time)) {
record_time <- py_to_r(record$base_time)
}
if (!is.null(record_date) && !is.null(record_time)) {
if (inherits(record_date, "Date") && inherits(record_time, c("hms", "character"))) {
time_str <- as.character(record_time)
datetime_str <- paste(as.character(record_date), time_str)
recording_datetime <- as.POSIXct(datetime_str, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
} else {
cat("  Warning: Could not combine date and time into a single POSIXct object for:", base_path, "\n")
}
}
cat("Dimensions of p_signal:", paste(dim(record$p_signal), collapse = "x"), "\n")
cat("Available signal names:", paste(record$sig_name, collapse = ", "), "\n")
p_signal_r_matrix <- py_to_r(record$p_signal)
signal <- p_signal_r_matrix[, 1] # Select the first lead (Lead I)
if (is.null(signal) || !is.numeric(signal) || length(signal) == 0) {
cat("Error: 'signal' is invalid or empty after selection for:", base_path, "\n")
return(NULL)
}
fs <- record$fs
cat("Signal length:", length(signal), "samples\n")
if (length(signal) <= 2253) {
cat("  Skipping: signal too short (", length(signal), "samples)\n")
return(NULL)
}
ecg <- import("biosppy.signals.ecg")
out_py <- ecg$ecg(signal = signal, sampling_rate = fs, show = FALSE)
out_dict_py <- out_py$as_dict()
out_r_list <- py_to_r(out_dict_py)
rpeaks <- NULL
heart_rate <- NULL
if ("rpeaks" %in% names(out_r_list)) {
rpeaks <- out_r_list$rpeaks
} else {
cat("  Warning: 'rpeaks' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if ("heart_rate" %in% names(out_r_list)) {
heart_rate <- out_r_list$heart_rate
} else {
cat("  Warning: 'heart_rate' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if (is.null(rpeaks) || length(rpeaks) < 2) {
cat("  Skipping: Not enough R-peaks found (", length(rpeaks), ") or rpeaks is NULL for RR-intervals for:", base_path, "\n")
return(NULL)
}
rr_intervals <- diff(rpeaks) / fs # Still calculate original rr_intervals
if (is.null(heart_rate) || length(heart_rate) == 0) {
cat("  Skipping: Heart rate data is missing or empty for:", base_path, "\n")
return(NULL)
}
# --- NEW: Align and pad beat-level data for unnesting ---
# Target length will be the number of rpeaks
num_rpeaks <- length(rpeaks)
# Pad rr_intervals: It's always length(rpeaks) - 1. Add NA at the beginning to align with rpeaks.
aligned_rr_intervals <- c(NA, rr_intervals)
# Pad heart_rate: Biosppy's heart_rate is usually length(rpeaks) - 1.
# Pad it to match rpeaks length.
aligned_heart_rate <- c(NA, heart_rate)
# Ensure both padded vectors are exactly num_rpeaks long, just in case heart_rate was shorter/longer
if (length(aligned_rr_intervals) < num_rpeaks) {
aligned_rr_intervals <- c(aligned_rr_intervals, rep(NA, num_rpeaks - length(aligned_rr_intervals)))
} else if (length(aligned_rr_intervals) > num_rpeaks) { # Truncate if somehow longer
aligned_rr_intervals <- head(aligned_rr_intervals, num_rpeaks)
}
if (length(aligned_heart_rate) < num_rpeaks) {
aligned_heart_rate <- c(aligned_heart_rate, rep(NA, num_rpeaks - length(aligned_heart_rate)))
} else if (length(aligned_heart_rate) > num_rpeaks) { # Truncate if somehow longer
aligned_heart_rate <- head(aligned_heart_rate, num_rpeaks)
}
# Create a nested tibble containing the aligned beat-level data
# This inner tibble will have columns of equal length (num_rpeaks)
beat_data_tibble <- tibble(
rpeak_index = rpeaks,           # Index of the R-peak in the original signal
rr_interval_s = aligned_rr_intervals, # RR-interval in seconds (NA for first peak)
heart_rate_bpm = aligned_heart_rate   # Heart rate in BPM (NA for first peak)
)
# --- Return the main tibble with the nested 'beat_data' list-column ---
participant_df <- tibble(
participant_id = participant_id,
record_date = record_date,
record_time = record_time,
recording_datetime = recording_datetime,
mean_hr = mean(heart_rate, na.rm = TRUE), # These use the original heart_rate vector
sdnn = sd(rr_intervals, na.rm = TRUE),   # These use the original rr_intervals vector
beat_data = list(beat_data_tibble) # The nested tibble becomes a list-column
)
return(participant_df)
}, error = function(e) {
cat("Error processing file:", base_path, "\n")
cat("Error message:", e$message, "\n")
return(NULL)
})
}
library(reticulate)
library(tidyverse) # This loads dplyr and tidyr, along with tibble and other useful packages
# --- Your existing setup for participant_folders ---
folder_path <- "/Users/delfarah/Desktop/aireadi/dataset/cardiac_ecg/ecg_12lead/philips_tc30/" # Adjust if needed
participant_folders <- list.dirs(path = folder_path, recursive = FALSE, full.names = FALSE)
participant_folders <- participant_folders[participant_folders != "."]
# Limiting to first 2 folders for testing, remove this line for full run
participant_folders <- participant_folders[1:2]
# --- Initialize list to store data frames (each with the nested beat_data list-column) ---
all_participants_ecg_raw <- list()
for (folder in participant_folders) {
folder_path_full <- file.path(folder_path, folder)
files <- list.files(folder_path_full, pattern = "\\.hea$", full.names = TRUE)
if (length(files) == 0) {
cat("No .hea files found in folder:", folder, "\n")
next
}
base_path <- sub("\\.hea$", "", files[1])
features_tibble <- extract_ecg_features(base_path)
if (!is.null(features_tibble)) {
all_participants_ecg_raw[[length(all_participants_ecg_raw) + 1]] <- features_tibble
}
}
# --- Post-processing: Combine and Flatten to Long Format ---
cat("\n--- Combining and Flattening Data ---\n")
if (length(all_participants_ecg_raw) == 0) {
cat("No data was successfully extracted from any participant.\n")
final_flat_ecg_data <- tibble() # Create an empty tibble
} else {
# 1. Combine all individual participant tibbles into one large tibble
combined_ecg_data <- bind_rows(all_participants_ecg_raw)
# 2. Use unnest() on the single 'beat_data' list-column
# This will expand the rows for each beat, and all columns within 'beat_data'
# are now guaranteed to be of equal length due to the padding in extract_ecg_features.
final_flat_ecg_data <- combined_ecg_data %>%
unnest(beat_data) # Only unnest the 'beat_data' list-column
cat("Successfully created a single, long-format data frame.\n")
cat("Final data frame dimensions:", dim(final_flat_ecg_data)[1], "rows,", dim(final_flat_ecg_data)[2], "columns.\n")
}
# You can now work with 'final_flat_ecg_data'
# It will have columns like:
# participant_id, record_date, record_time, recording_datetime, mean_hr, sdnn,
# rpeak_index, rr_interval_s, heart_rate_bpm
View(final_flat_ecg_data)
# install.packages("reticulate")
# reticulate::py_install(c("wfdb", "biosppy", "matplotlib", "numpy"))
#reticulate::py_install("peakutils")
library(reticulate)
folder_id <- "dataset/cardiac_ecg/ecg_12lead/philips_tc30"
folder_path <- file.path(getwd(), folder_id)
# Use a conda or virtualenv environment if needed
# use_condaenv("your-env")  # optional
# Import required Python modules
wfdb <- import("wfdb")
biosppy <- import("biosppy.signals.ecg")
np <- import("numpy")
# Function to extract features from one ECG file
library(reticulate)
library(tibble)
extract_ecg_features <- function(base_path) {
tryCatch({
record <- wfdb$rdrecord(base_path)
if (is.null(record) || is.null(record$p_signal) || length(dim(record$p_signal)) < 2) {
cat("Error: Problem reading record or p_signal for:", base_path, "\n")
if (!is.null(record) && !is.null(record$p_signal)) {
cat("  Dimensions of p_signal:", paste(dim(record$p_signal), collapse = "x"), "\n")
}
return(NULL)
}
participant_id <- basename(dirname(base_path))
cat("Processing Participant ID:", participant_id, "\n")
# --- Extract time and date information ---
record_date <- NULL
record_time <- NULL
recording_datetime <- NULL
if (!is.null(record$base_date)) {
record_date <- py_to_r(record$base_date)
}
if (!is.null(record$base_time)) {
record_time <- py_to_r(record$base_time)
}
if (!is.null(record_date) && !is.null(record_time)) {
if (inherits(record_date, "Date") && inherits(record_time, c("hms", "character"))) {
time_str <- as.character(record_time)
datetime_str <- paste(as.character(record_date), time_str)
recording_datetime <- as.POSIXct(datetime_str, format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
} else {
cat("  Warning: Could not combine date and time into a single POSIXct object for:", base_path, "\n")
}
}
cat("Dimensions of p_signal:", paste(dim(record$p_signal), collapse = "x"), "\n")
cat("Available signal names:", paste(record$sig_name, collapse = ", "), "\n")
p_signal_r_matrix <- py_to_r(record$p_signal)
signal <- p_signal_r_matrix[, 1] # Select the first lead (Lead I)
if (is.null(signal) || !is.numeric(signal) || length(signal) == 0) {
cat("Error: 'signal' is invalid or empty after selection for:", base_path, "\n")
return(NULL)
}
fs <- record$fs
cat("Signal length:", length(signal), "samples\n")
if (length(signal) <= 2253) {
cat("  Skipping: signal too short (", length(signal), "samples)\n")
return(NULL)
}
ecg <- import("biosppy.signals.ecg")
out_py <- ecg$ecg(signal = signal, sampling_rate = fs, show = FALSE)
out_dict_py <- out_py$as_dict()
out_r_list <- py_to_r(out_dict_py)
rpeaks <- NULL
heart_rate <- NULL
if ("rpeaks" %in% names(out_r_list)) {
rpeaks <- out_r_list$rpeaks
} else {
cat("  Warning: 'rpeaks' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if ("heart_rate" %in% names(out_r_list)) {
heart_rate <- out_r_list$heart_rate
} else {
cat("  Warning: 'heart_rate' element not found in biosppy output (after dict conversion) for:", base_path, "\n")
return(NULL)
}
if (is.null(rpeaks) || length(rpeaks) < 2) {
cat("  Skipping: Not enough R-peaks found (", length(rpeaks), ") or rpeaks is NULL for RR-intervals for:", base_path, "\n")
return(NULL)
}
rr_intervals <- diff(rpeaks) / fs # Still calculate original rr_intervals
if (is.null(heart_rate) || length(heart_rate) == 0) {
cat("  Skipping: Heart rate data is missing or empty for:", base_path, "\n")
return(NULL)
}
# --- NEW: Align and pad beat-level data for unnesting ---
# Target length will be the number of rpeaks
num_rpeaks <- length(rpeaks)
# Pad rr_intervals: It's always length(rpeaks) - 1. Add NA at the beginning to align with rpeaks.
aligned_rr_intervals <- c(NA, rr_intervals)
# Pad heart_rate: Biosppy's heart_rate is usually length(rpeaks) - 1.
# Pad it to match rpeaks length.
aligned_heart_rate <- c(NA, heart_rate)
# Ensure both padded vectors are exactly num_rpeaks long, just in case heart_rate was shorter/longer
if (length(aligned_rr_intervals) < num_rpeaks) {
aligned_rr_intervals <- c(aligned_rr_intervals, rep(NA, num_rpeaks - length(aligned_rr_intervals)))
} else if (length(aligned_rr_intervals) > num_rpeaks) { # Truncate if somehow longer
aligned_rr_intervals <- head(aligned_rr_intervals, num_rpeaks)
}
if (length(aligned_heart_rate) < num_rpeaks) {
aligned_heart_rate <- c(aligned_heart_rate, rep(NA, num_rpeaks - length(aligned_heart_rate)))
} else if (length(aligned_heart_rate) > num_rpeaks) { # Truncate if somehow longer
aligned_heart_rate <- head(aligned_heart_rate, num_rpeaks)
}
# Create a nested tibble containing the aligned beat-level data
# This inner tibble will have columns of equal length (num_rpeaks)
beat_data_tibble <- tibble(
rpeak_index = rpeaks,           # Index of the R-peak in the original signal
rr_interval_s = aligned_rr_intervals, # RR-interval in seconds (NA for first peak)
heart_rate_bpm = aligned_heart_rate   # Heart rate in BPM (NA for first peak)
)
# --- Return the main tibble with the nested 'beat_data' list-column ---
participant_df <- tibble(
participant_id = participant_id,
record_date = record_date,
record_time = record_time,
recording_datetime = recording_datetime,
mean_hr = mean(heart_rate, na.rm = TRUE), # These use the original heart_rate vector
sdnn = sd(rr_intervals, na.rm = TRUE),   # These use the original rr_intervals vector
beat_data = list(beat_data_tibble) # The nested tibble becomes a list-column
)
return(participant_df)
}, error = function(e) {
cat("Error processing file:", base_path, "\n")
cat("Error message:", e$message, "\n")
return(NULL)
})
}
participant_folders <- list.dirs(path = folder_path, recursive = FALSE, full.names = FALSE)
participant_folders <- participant_folders[participant_folders != "."]
# --- Initialize list to store data frames (each with the nested beat_data list-column) ---
all_participants_ecg_raw <- list()
for (folder in participant_folders) {
folder_path_full <- file.path(folder_path, folder)
files <- list.files(folder_path_full, pattern = "\\.hea$", full.names = TRUE)
if (length(files) == 0) {
cat("No .hea files found in folder:", folder, "\n")
next
}
base_path <- sub("\\.hea$", "", files[1])
features_tibble <- extract_ecg_features(base_path)
if (!is.null(features_tibble)) {
all_participants_ecg_raw[[length(all_participants_ecg_raw) + 1]] <- features_tibble
}
}
# --- Post-processing: Combine and Flatten to Long Format ---
cat("\n--- Combining and Flattening Data ---\n")
if (length(all_participants_ecg_raw) == 0) {
cat("No data was successfully extracted from any participant.\n")
al_participant_ecg <- tibble() # Create an empty tibble
} else {
# 1. Combine all individual participant tibbles into one large tibble
combined_ecg_data <- bind_rows(all_participants_ecg_raw)
# 2. Use unnest() on the single 'beat_data' list-column
# This will expand the rows for each beat, and all columns within 'beat_data'
# are now guaranteed to be of equal length due to the padding in extract_ecg_features.
al_participant_ecg <- combined_ecg_data %>%
unnest(beat_data) # Only unnest the 'beat_data' list-column
cat("Successfully created a single, long-format data frame.\n")
cat("Final data frame dimensions:", dim(al_participant_ecg)[1], "rows,", dim(al_participant_ecg)[2], "columns.\n")
}
View(all_participants_ecg_raw)
View(all_participants_ecg_raw)
all_participants_ecg_raw[[1]]
View(al_participant_ecg)
saveRDS(all_participants_ecg, "aireadi_ecg.rda")
temp <- read_csv("/Users/delfarah/Desktop/aireadi/dataset/environment/environmental_sensor/leelab_anura/1001/1001_ENV.csv")
View(temp)
folder_id <- "dataset/clinical_data"
folder_path <- file.path(getwd(), folder_id)
csv_files <- list.files(path = folder_path, pattern = "\\.csv$", full.names = TRUE)
csv_files
folder_id <- "dataset/clinical_data"
folder_path <- file.path(getwd(), folder_id)
csv_files <- list.files(path = folder_path, pattern = "\\.csv$", full.names = TRUE)
# Initialize an empty list to store the data frames
all_clinical <- list()
# Check if any CSV files were found
if (length(csv_files) == 0) {
message("No CSV files found in the specified directory: ", csv_directory)
} else {
# Loop through each CSV file
for (file_path in csv_files) {
# Extract the file name without the extension to use as a list element name
file_name <- tools::file_path_sans_ext(basename(file_path))
cat("Reading file: ", basename(file_path), "\n")
# Use tryCatch for robust error handling in case a file is malformed
tryCatch({
# Read the CSV file into a tibble
df <- read_csv(file_path, show_col_types = FALSE) # show_col_types = FALSE suppresses the column type message for each file
# Store the data frame in the list using its name
all_clinical[[file_name]] <- df
cat("  Successfully read '", file_name, "'. Dimensions: ", nrow(df), " rows, ", ncol(df), " columns.\n", sep = "")
}, error = function(e) {
cat("  Error reading file '", basename(file_path), "': ", e$message, "\n", sep = "")
})
}
}
View(all_clinical)
View(all_clinical[["condition_occurrence"]])
saveRDS(all_clinical, "aireadi_clinical.rda")
usethis::create_from_github("https://github.com/delfarahalireza/aireadi.git")
load("~/Desktop/aireadi_dataset/aireadi_sleep.rda")
